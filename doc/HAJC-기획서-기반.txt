개요

HAJC는 Hardware Accelerated JIT(Just in time) Compiler의 약자입니다.
이 솔루션은 대부분의 프로그램들이 CPU의 하위 호환성을 위해, 모든 CPU의 기능들을 사용할 수 없다는 점을 해결하기 위해 만들어졌습니다.
HAJC는 기존의 Lagacy코드들을 사용자의 CPU에 맞춰서 다시 Recompile(Porting) 또는 최적화를 담당합니다.
또는 기존의 JIT Compiler처럼 HAJC IR을 Just In Time 컴파일하여, 마찬가지로 사용자의 CPU에 맞게 컴파일되고, 하드웨어에 캐싱(AOT)하게됩니다.
이 기능들은 CPU레벨에서 처리하기에는 너무나 무겁습니다. 그래서 HAJC는 Compile에 특화된 하드웨어를 제작하여. Compile의 성능과 비용(Cost)를 크게 줄이고자 만들어졌습니다.

기존의 문제점.

기존의 프로그램들은 CPU마다, Platform마다 다른 컴파일러, 다른 성능, 다른 기능을 가지고 있어. 코드 본연의 모든 기능을 활용할 수 없었습니다.
개발자들은 유저들이 기존에 사용하는 오래된 CPU 또는 Platform을 지원하기 위해 Lagacy명령어들을 사용하도록 설계했습니다. 많은 유저들이 사용할 수 있도록 만들어야 했기 때문인데요.
이 Lagacy명령어들을 최신 CPU에서 사용하게 된다면 최신 CPU에서 사용하는 여러가지 새로운 명령어들을 사용할 수 없게 됩니다. (EX. AVX-512)
이것을 해결하기 위해 나온 것이 JIT(Just in time) Compile입니다. JIT(Just in time) Compiler는 프로그램이 실행될 때에.
프로그램을 자신의 Platform이나 CPU에 맞게 컴파일 하게 됩니다. 지금 존재하는 Java나 C# (.NET) 등등이 이에 해당되지요.
하지만 지금까지 나온 JIT(Just in time) Compiler들은 이 Compile 할때의 작업, 즉 최적화화는 작업의 비용(Cost)때문에 제대로 빛을 발하지 못했습니다.
그 이유는 이 JIT Compiler가 만들어낸 최적화한 코드의 성능보다 최적화할때의 비용(Cost)가 훨씬 컸기 때문이였습니다.

문제점에 대한 해결.

그러면 이 비용(Cost)를 줄이기 위해서 "어떻게" 해야 할 지를 생각했습니다. 여러 방법을 시도해보았지만, Compile이라는 작업은 제가 상상한것 이상으로 많이 무거웠습니다.
현제의 Compile이라는 작업을 가볍게 만들고, Compile 이후의 결과물의 성능을 향상시키기 위해서는. 개개인의 컴퓨터에 특화되어 맞춰진 컴파일러를 제작해야했습니다.
하지만 컴퓨터 개개인에 특화된 컴파일러를 하나하나 제작하기란 불가능했습니다. 이 Compiler라는게 생각보다 만들기 힘든 프로그램이거든요. 
얼마나 이 프로그램이 복잡하고 무거웠으면 제 컴퓨터에서 LLVM(JIT Compiler중 하나)를 컴파일하는데에만 4시간이 걸릴 정도였으니까요. 이런 걸 플렛폼마다 하나하나 만들자구요?
그래서 다시 생각했지요. 그러면 차라리 GPU처럼 "Compile"이라는 작업에 특화된 하드웨어를 만들면 어떨까 라고. 그렇다면 적은 리소스를 사용하고, 더 빠르게 Compile이라는 작업을 할 수 있지 않을까 라고요.
그렇게 만들어진 해결법이 이 HAJC입니다.

HAJC의 원리.

HAJC는 지금과는 다른 방법의 컴파일 방식을 사용합니다. 기존의 IR Language를 불편하게 java.exe(JVM)라던지 lit.exe(LLVM)라던지를 불편하게 사용하지 않아도 됩니다.
단순히 기존과 같이 프로그램을 더블클릭하여 실행하면, 프로그램이 OS에 등록되어있는 Hardware Driver 를 통해 PCI-E에 있는 HAJC Device에 전달되고 컴파일되어 캐시(AOT)되고, 주기억장치(RAM)로 이동하여 실행되게 됩니다. 
이 중에 컴파일 되는 과정에서 HAJC Device는 이것이 IR인지 Assembly(기계어)인지 확인하여, IR일 경우엔 CPU에 맞게 Compile을, Assembly(기계어)인 경우엔 CPU에 맞게 최적화를 이행합니다.
이것이 HAJC Device가 CPU 또는 Platform마다 최적화된 Assembly(기계어)를 CPU에게 전달하는 과정입니다.
이 과정을 통해 프로그램들은 CPU, Platform을 최대한 모두 다 활용할 수 있게 됩니다. 이것은 엄청난 량의 속도 향상을 의미합니다.

HAJC의 효과.

그렇다면 HAJC로 인해서 어떤 부분이 향상되었을까요? 하드웨어를 사용함으로서 CPU의 오버헤드를 줄이는 부분을 제외한, 순수한 성능 향상을 비교해보록 하겠습니다.
일단, 보통 프로그램들은 SSE2 명령어 (팬티엄 시절의 명령어)를 기반으로 설게됩니다. SSE2 명령어의 경우에는. 128Bit 크기의 숫자를 저장할 수 있습니다. 32Bit 크기의 숫자를 4개 저장 할 수 있고 한번에 계산 할 수 있지요.
그렇다면 최신 기술인 AVX 명령어 (하즈웰 이상)의 경우엔 어떨까요? AVX 명령어의 경우에는 총 256Bit 크기의 숫자를 저장합니다. 무려 2배 차이입니다. 32Bit 크기의 숫자를 8개 저장하고 8개를 동시에 계산 할 수 있지요.
명령어의 속도를 제외하고 단순히 한번에 계산하는 숫자만으로도 2배의 차이가 납니다. 추가로 이전에 말씀드린듯이 명령어의 속도 차이를 제외하고도 말이죠.

다음은 프로그래머들에 대한 이야기입니다.
프로그래머들은 만약 유저들이 HAJC를 사용하게된다면. 더이상 CPU나 Platform마다 같은 프로그램을 여러게 만들 필요가 없습니다.
단순히 HAJC Frontend로 코드를 HAJC IR로 컴파일하고 배포한다면. 그 HAJC IR이 자동으로 HAJC Device에 의해 자신의 CPU나 Platform에 맞도록 Assembly(기계어)를 생성하게됩니다.
새로운 언어를 배워야 할 필요도 없습니다. 이 HAJC Frontend는 HAJC API를 통해 LLVM처럼 HAJC IR에 대한 Toolchain을 제공할 것이며, 이 Toolchian은 개발자들이 원하는 언어에 Binding 하는 것으로 HAJC Device를 이용할 수 있게 됩니다.
이것은 엄청난 패러다임입니다. 이것은 CPU와 Platform간의 벽을 허무는것이고. 궁극적으로는 모든 종류의 PC가 원하는 프로그램을, 다양한 프로그래밍 언어로 작성된 코드를 실행 할수 있는 날이 온다는 것이니까요.

결론.
보다시피 HAJC Device를 장착하고 드라이버를 설치하는것만으로도 유저들이 사용하는 CPU와 플렛폼의 성능을 완전히 사용할 수 있게됩니다.
이것은 CPU클럭, 코어 갯수, SSD처럼 새로운 성능 향상과 성능의 기준이 만들어질것이며,
HAJC Frontend와 HAJC IR를 이용하는것으로 CPU와 Platform의 벽을 부수어 프로그램 개발과 이용에 대한 새로운 패러다임이 만들어질 것입니다.

JIT(Just in time)* : Just in time이란 그 시간에 무언가를 한다는 의미입니다. JIT Compile 같은 경우에는 프로그램이 실행 될 때에 Compile 된다는 의미입니다.
Compile* : Compile은 보통 프로그래머들이 작성한 코드를 기계가 이해할 수 있는 Assembly로 바꾸어주는 작업을 말합니다.
Assembly* : Assembly는 보통 CPU 레벨에서 CPU가 이해할 수 있는 기계어를 의미합니다.
Lagacy 명령어* : 오래된 명령어를 의미합니다. 최신의 CPU는 계산을 병렬로 이행할수있는 AVX(Intel) 등등을 지원합니다.
Hardware Driver* : 프로그램에서 하드웨어로 통하는 통로입니다. OS에 의해서 관리됩니다. 이것을 통해 하드웨어와 소프트웨어가 통신할 수 있습니다.
AOT : ahead-of-time 을 의미합니다. 이것은 프로그램이 실행될때 JIT 컴파일한 결과물을 일시적으로 저장함을 의미합니다. 이것은 이 프로그램이 다시 JIT 컴파일하는것을 방지합니다.
IR Language* : 중간 언어라는 뜻입니다. 보통 Compile이라는 작업을 거치면 기계어로 변환되는데, JIT Compile을 지원하는 언어인 경우에는 IR 언어로 변환됩니다. 이 IR언어는 기계어와 프로그래머가 작성한 의사 코드 중간에 위치합니다.
Platform : 플렛폼은 보통 환경을 의미합니다, CPU나 OS 등등을 통칭하여 Platform이라고 합니다.
JVM, LLVM : JVM은 Java의 JIT Compiler입니다, LIT은 LLVM의 JIT Compiler입니다.
